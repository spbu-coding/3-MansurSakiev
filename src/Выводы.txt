Выводы по задаче:
Изначально float_delta и double_delta равны 0.00000000000000000000
Берем формулу и подгоняем под наши float и doble:
float:
 answer_f.x2 = (2.0001f + delta - 2) * pow(10, 4);
 answer_f.x1 = 2.0000f - answer_f.x2;
 
 double:
 answer_d.x2 = (2.0001 + delta - 2) * pow(10, 4);
 answer_d.x1 = 2.0000 - answer_d.x2;
 
 Смотрим на значения наших point'ов:
 double_point: x1 = 1.00000000000000000000 x2 = 1.00000000000000000000
 float_point: x1 = 1.00102615356445310000 x2 = 0.99897384643554688000
 
 Присваеваем float_delta и double_delta следующие значения:
 float_delta = 0.00001f;
 double_delta = 0.00001;
 
 Смотрим на значения новых point'ов:
 New double points: x1 = 0.89999997615814209000  x2 = 1.10000002384185790000
 new float points: x1 = 0.90089035034179688000  x2 = 1.09910964965820310000
 
 Находим расстояние между новыми и старыми точками.
 Зацикливаем деление delt'ы на 2
 Как только растояние между точками больше 10^-6 эксперимент завершится.
 В моём эксперименте 22 повторения цикла.
 В следствия выполнения эксперимента отклонения  double и float уменьшились:
 Но у double в 2^22 раза
 А у  float в 2^11 раз
 
 Доп. Вывод: double выглядит предпочтительнее для решения проблем, так как в одинаковых условиях погрешность у double будет в два раза меньше чем у float.
 

 
 
 
